from fastapi import FastAPI, APIRouter, HTTPException, Depends, status, Request, Response, File, UploadFile
from fastapi.security import OAuth2PasswordBearer, OAuth2PasswordRequestForm
from fastapi.responses import JSONResponse
from fastapi.middleware.cors import CORSMiddleware
from fastapi.staticfiles import StaticFiles
from dotenv import load_dotenv
from pathlib import Path
from motor.motor_asyncio import AsyncIOMotorClient
import os
import logging
from pathlib import Path
from pydantic import BaseModel, Field, ConfigDict
from typing import List, Optional
import uuid
from datetime import datetime, timezone, timedelta
import requests
from urllib.parse import quote
from zoneinfo import ZoneInfo
import re
import xml.etree.ElementTree as ET

from contextlib import asynccontextmanager
from passlib.context import CryptContext
from jose import JWTError, jwt
from apscheduler.schedulers.asyncio import AsyncIOScheduler
from apscheduler.triggers.interval import IntervalTrigger
import socketio

# (Cache ve Rate Limit importlarÄ±, sizin projenizden alÄ±ndÄ±)
from cache import init_redis, invalidate_cache, cache_result
from rate_limit import initialize_limiter, rate_limit, LIMITS
from slowapi.errors import RateLimitExceeded
from slowapi import _rate_limit_exceeded_handler

# === LOGGING AYARLARI ===
logging.basicConfig(
    level=logging.INFO,  # INFO level for production
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('/tmp/backend.log')
    ]
)
logger = logging.getLogger(__name__)
# Enable socketio server logging
logging.getLogger('socketio.server').setLevel(logging.INFO)
logging.getLogger('engineio.server').setLevel(logging.INFO)

# === GÃœVENLÄ°K AYARLARI ===
SECRET_KEY = os.environ.get('JWT_SECRET_KEY', 'default_karmaÅŸÄ±k_bir_secret_key_ekleyin_mutlaka')
if SECRET_KEY == 'default_karmaÅŸÄ±k_bir_secret_key_ekleyin_mutlaka':
    logging.warning("WARNING: JWT_SECRET_KEY is using default value! Please set a secure secret key in production.")
ALGORITHM = "HS256"
ACCESS_TOKEN_EXPIRE_MINUTES = 60 * 24
pwd_context = CryptContext(schemes=["bcrypt"], deprecated="auto")
oauth2_scheme = OAuth2PasswordBearer(tokenUrl="/api/token")

# --- ROOT DÄ°ZÄ°N VE .ENV YÃœKLEME ---
ROOT_DIR = Path(__file__).parent
load_dotenv(ROOT_DIR / '.env')

# --- SABÄ°T SMS AYARLARI ---
ILETIMERKEZI_API_KEY = os.environ.get('ILETIMERKEZI_API_KEY')
ILETIMERKEZI_HASH = os.environ.get('ILETIMERKEZI_HASH')
ILETIMERKEZI_SENDER = os.environ.get('ILETIMERKEZI_SENDER', 'FatihSenyuz') 
SMS_ENABLED = os.environ.get('SMS_ENABLED', 'true').lower() in ('1', 'true', 'yes')

# === SMS REMINDER SCHEDULER ===
scheduler = AsyncIOScheduler()

async def check_and_send_reminders():
    """Her 5 dakikada bir yaklaÅŸan randevularÄ± kontrol et ve SMS gÃ¶nder"""
    try:
        if not _mongo_db:
            return
        
        turkey_tz = ZoneInfo("Europe/Istanbul")
        now = datetime.now(turkey_tz)
        
        # TÃ¼m organization'larÄ±n ayarlarÄ±nÄ± al
        all_settings = await _mongo_db.settings.find({}, {"_id": 0}).to_list(1000)
        
        for setting in all_settings:
            org_id = setting.get('organization_id')
            reminder_hours = setting.get('sms_reminder_hours', 1.0)
            company_name = setting.get('company_name', 'Ä°ÅŸletmeniz')
            support_phone = setting.get('support_phone', 'Destek')
            
            # HatÄ±rlatma zaman aralÄ±ÄŸÄ±nÄ± hesapla
            reminder_time_start = now + timedelta(hours=reminder_hours - 0.1)  # 6 dakika tolerance
            reminder_time_end = now + timedelta(hours=reminder_hours + 0.1)
            
            # Bu zaman aralÄ±ÄŸÄ±ndaki randevularÄ± bul
            appointments = await _mongo_db.appointments.find({
                "organization_id": org_id,
                "status": "Bekliyor",
                "reminder_sent": {"$ne": True}  # Daha Ã¶nce hatÄ±rlatma gÃ¶nderilmemiÅŸ
            }, {"_id": 0}).to_list(1000)
            
            for apt in appointments:
                try:
                    # Randevu zamanÄ±nÄ± parse et
                    apt_datetime_str = f"{apt['appointment_date']} {apt['appointment_time']}"
                    apt_datetime = datetime.strptime(apt_datetime_str, "%Y-%m-%d %H:%M").replace(tzinfo=turkey_tz)
                    
                    # HatÄ±rlatma zamanÄ± geldi mi?
                    if reminder_time_start <= apt_datetime <= reminder_time_end:
                        # SMS gÃ¶nder
                        sms_message = (
                            f"SayÄ±n {apt['customer_name']},\n\n"
                            f"{company_name} randevunuz {reminder_hours} saat sonra!\n\n"
                            f"Tarih: {apt['appointment_date']}\n"
                            f"Saat: {apt['appointment_time']}\n"
                            f"Hizmet: {apt['service_name']}\n\n"
                            f"Bilgi: {support_phone}\n\n"
                            f"â€” {company_name}"
                        )
                        
                        send_sms(apt['phone'], sms_message)
                        
                        # HatÄ±rlatma gÃ¶nderildi olarak iÅŸaretle
                        await _mongo_db.appointments.update_one(
                            {"id": apt['id']},
                            {"$set": {"reminder_sent": True}}
                        )
                        
                        logging.info(f"SMS reminder sent to {apt['customer_name']} for appointment {apt['id']}")
                
                except Exception as e:
                    logging.error(f"Error sending reminder for appointment {apt.get('id')}: {e}")
    
    except Exception as e:
        logging.error(f"Error in check_and_send_reminders: {e}")

# === MongoDB ve Redis YaÅŸam DÃ¶ngÃ¼sÃ¼ (Lifespan) --- SYNTAX HATASI DÃœZELTÄ°LDÄ° ===
@asynccontextmanager
async def lifespan(app: FastAPI):
    app.mongodb_client = None; app.db = None; app.redis_client = None
    try:
        logging.info("Step 1: Connecting to MongoDB..."); mongo_url = os.environ.get('MONGO_URL'); db_name = os.environ.get('DB_NAME', 'royal_koltuk_dev')
        if not mongo_url:
            logging.error("CRITICAL: MONGO_URL environment variable is required!"); logging.warning("MongoDB connection will be lazy-initialized on first request.")
        else:
            try:
                app.mongodb_client = AsyncIOMotorClient(mongo_url, serverSelectionTimeoutMS=5000); await app.mongodb_client.admin.command('ping')
                app.db = app.mongodb_client[db_name]; logging.info(f"Step 1 SUCCESS: Successfully connected to MongoDB ({db_name})!")
            except Exception as mongo_error:
                logging.warning(f"MongoDB connection failed during startup: {mongo_error}"); logging.info("MongoDB will be lazy-initialized on first request.")
    except Exception as e:
        logging.warning(f"WARNING during MongoDB connection: {type(e).__name__}: {str(e)}"); app.mongodb_client = None; app.db = None
    try:
        logging.info("Step 2: Initializing Redis..."); app.redis_client = await init_redis()
        if app.redis_client:
            try: await app.redis_client.ping(); logging.info("Step 2 SUCCESS: Redis initialized and ping successful.")
            except Exception as redis_ping_error: logging.warning(f"Redis ping failed: {redis_ping_error}"); app.redis_client = None
        else: logging.warning("WARNING: Redis client could not be initialized (init_redis returned None).")
    except Exception as e:
        logging.warning(f"WARNING during Redis connection: {type(e).__name__}: {str(e)}"); app.redis_client = None
    try:
        logging.info("Step 3: Initializing Rate Limiter...")
        if app.redis_client is None: logging.warning("WARNING: Using dummy Rate Limiter due to failed Redis connection.")
        app.state.limiter = initialize_limiter(app.redis_client); logging.info("Step 3 SUCCESS: Rate Limiter initialized.")
    except Exception as e:
        logging.warning(f"WARNING during Rate Limiter initialization: {type(e).__name__}: {str(e)}"); app.state.limiter = None
    
    try:
        logging.info("Step 4: Starting SMS Reminder Scheduler...")
        scheduler.add_job(check_and_send_reminders, IntervalTrigger(minutes=5), id='sms_reminder_job')
        scheduler.start()
        logging.info("Step 4 SUCCESS: SMS Reminder Scheduler started (runs every 5 minutes)")
    except Exception as e:
        logging.warning(f"WARNING during Scheduler initialization: {type(e).__name__}: {str(e)}")
    
    try:
        logging.info("Step 5: Creating Database Indexes...")
        if app.db is not None:
            # Appointments indexes - Performance optimization
            await app.db.appointments.create_index([("organization_id", 1), ("appointment_date", -1)])
            await app.db.appointments.create_index([("organization_id", 1), ("staff_member_id", 1)])
            await app.db.appointments.create_index([("organization_id", 1), ("phone", 1)])
            await app.db.appointments.create_index([("organization_id", 1), ("status", 1)])
            
            # Users indexes
            await app.db.users.create_index([("organization_id", 1), ("role", 1)])
            try:
                await app.db.users.create_index([("slug", 1)], unique=True, sparse=True)
            except Exception as idx_err:
                # Index might already exist or have duplicate null values, skip
                logging.debug(f"Users slug index creation skipped: {idx_err}")
            
            # Settings indexes
            await app.db.settings.create_index([("organization_id", 1)], unique=True)
            try:
                await app.db.settings.create_index([("slug", 1)], unique=True, sparse=True)
            except Exception as idx_err:
                # Index might already exist or have duplicate null values, skip
                logging.debug(f"Settings slug index creation skipped: {idx_err}")
            
            logging.info("Step 5 SUCCESS: Database indexes created")
        else:
            logging.warning("Step 5 SKIPPED: Database not available")
    except Exception as e:
        logging.warning(f"WARNING during Index creation: {type(e).__name__}: {str(e)}")

    yield

    # --- Cleanup bloklarÄ± ---
    if scheduler.running:
        logging.info("Stopping SMS Reminder Scheduler...")
        try: scheduler.shutdown()
        except: pass
    if app.mongodb_client:
        logging.info("Closing MongoDB connection...")
        try: app.mongodb_client.close()
        except: pass
    if app.redis_client:
        logging.info("Closing Redis connection...")
        try: await app.redis_client.close()
        except: pass

# Create the main app
app = FastAPI(title="Randevu SaaS API", description="... (AÃ§Ä±klamanÄ±z buradaydÄ±) ...", version="1.4.2 (Final Fixes)", lifespan=lifespan)
app.add_exception_handler(RateLimitExceeded, _rate_limit_exceeded_handler)

# === SOCKET.IO SETUP ===
# Get CORS origins for Socket.IO (same as FastAPI CORS)
cors_origins_for_socketio = os.environ.get('CORS_ORIGINS', '*')
if cors_origins_for_socketio == '*':
    socketio_cors_origins = '*'
else:
    socketio_cors_origins = [origin.strip() for origin in cors_origins_for_socketio.split(',') if origin.strip()]

sio = socketio.AsyncServer(
    async_mode='asgi',
    cors_allowed_origins=socketio_cors_origins,
    logger=True,
    engineio_logger=False
)
socket_app = socketio.ASGIApp(sio, socketio_path='/api/socket.io', other_asgi_app=app)

# --- Router prefix'i kaldÄ±rÄ±ldÄ± ---
api_router = APIRouter()

# === SOCKET.IO EVENT HANDLERS ===
@sio.event
async def connect(sid, environ):
    """Client connected"""
    print(f"ðŸ”µ [CONNECT] WebSocket client connected: {sid}")  # Debug print
    logger.info(f"ðŸ”µ [CONNECT] WebSocket client connected: {sid}")
    logging.info(f"ðŸ”µ [CONNECT] WebSocket client connected: {sid}")  # Direct logging
    try:
        await sio.emit('connection_established', {'status': 'connected'}, room=sid)
        logger.info(f"âœ“ [CONNECT] Sent connection_established to {sid}")
    except Exception as e:
        logger.error(f"âœ— [CONNECT] Error sending connection_established: {e}", exc_info=True)

@sio.event
async def disconnect(sid):
    """Client disconnected"""
    logger.info(f"WebSocket client disconnected: {sid}")

@sio.event
async def join_organization(sid, data):
    """Join organization room for real-time updates"""
    print(f"ðŸŸ¢ [JOIN_ORG] join_organization event received from {sid} with data: {data}")  # Debug print
    logger.info(f"ðŸŸ¢ [JOIN_ORG] join_organization event received from {sid} with data: {data}")
    logging.info(f"ðŸŸ¢ [JOIN_ORG] join_organization event received from {sid} with data: {data}")  # Direct logging
    try:
        organization_id = data.get('organization_id')
        if organization_id:
            room_name = f"org_{organization_id}"
            await sio.enter_room(sid, room_name)
            print(f"âœ“ [JOIN_ORG] Client {sid} joined organization room: {room_name}")  # Debug print
            logger.info(f"âœ“ [JOIN_ORG] Client {sid} joined organization room: {room_name}")
            logging.info(f"âœ“ [JOIN_ORG] Client {sid} joined organization room: {room_name}")  # Direct logging
            # Get all rooms for this socket to verify
            try:
                rooms = await sio.get_session(sid)
                logger.info(f"ðŸ“‹ [JOIN_ORG] Socket {sid} session data: {rooms}")
            except Exception as session_error:
                logger.warning(f"âš  [JOIN_ORG] Could not get session for {sid}: {session_error}")
            await sio.emit('joined_organization', {'organization_id': organization_id}, room=sid)
            logger.info(f"âœ“ [JOIN_ORG] Sent joined_organization confirmation to {sid}")
        else:
            logger.warning(f"âš  [JOIN_ORG] join_organization called without organization_id from {sid}")
    except Exception as e:
        print(f"âœ— [JOIN_ORG] Error: {e}")  # Debug print
        logger.error(f"âœ— [JOIN_ORG] Error in join_organization: {e}", exc_info=True)
        logging.error(f"âœ— [JOIN_ORG] Error in join_organization: {e}", exc_info=True)  # Direct logging

@sio.event
async def leave_organization(sid, data):
    """Leave organization room"""
    organization_id = data.get('organization_id')
    if organization_id:
        await sio.leave_room(sid, f"org_{organization_id}")
        logger.info(f"Client {sid} left organization room: org_{organization_id}")

# Helper function to make data JSON serializable (convert ObjectId, datetime, etc.)
def make_json_serializable(obj):
    """Recursively convert MongoDB ObjectId and datetime objects to JSON-serializable types"""
    import json
    from bson import ObjectId
    from datetime import datetime, date
    
    if isinstance(obj, ObjectId):
        return str(obj)
    elif isinstance(obj, (datetime, date)):
        return obj.isoformat() if hasattr(obj, 'isoformat') else str(obj)
    elif isinstance(obj, dict):
        return {key: make_json_serializable(value) for key, value in obj.items()}
    elif isinstance(obj, list):
        return [make_json_serializable(item) for item in obj]
    elif isinstance(obj, tuple):
        return tuple(make_json_serializable(item) for item in obj)
    elif isinstance(obj, set):
        return {make_json_serializable(item) for item in obj}
    else:
        # Try to convert to JSON-serializable type
        try:
            json.dumps(obj)
            return obj
        except (TypeError, ValueError):
            # If not serializable, convert to string
            return str(obj)

# Helper function to emit events to organization rooms
async def emit_to_organization(organization_id: str, event: str, data: dict):
    """Emit event to all clients in an organization room"""
    try:
        room_name = f"org_{organization_id}"
        print(f"ðŸ“¤ [EMIT] About to emit {event} to room {room_name}")  # Debug print
        logger.info(f"ðŸ“¤ [EMIT] About to emit {event} to room {room_name}")
        logging.info(f"ðŸ“¤ [EMIT] About to emit {event} to room {room_name}")  # Direct logging
        
        # Convert data to JSON-serializable format
        serializable_data = make_json_serializable(data)
        
        # Get all sockets in the room to verify
        try:
            # Note: Socket.IO doesn't have a direct way to list room members, but we can try to emit
            await sio.emit(event, serializable_data, room=room_name)
            print(f"âœ“ [EMIT] Successfully emitted {event} to room {room_name}")  # Debug print
            logger.info(f"âœ“ [EMIT] Successfully emitted {event} to room {room_name} with data keys: {list(serializable_data.keys())}")
            logging.info(f"âœ“ [EMIT] Successfully emitted {event} to room {room_name}")  # Direct logging
        except Exception as emit_error:
            print(f"âœ— [EMIT] Error during emit: {emit_error}")  # Debug print
            logger.error(f"âœ— [EMIT] Error during emit to {room_name}: {emit_error}", exc_info=True)
            raise
    except Exception as e:
        print(f"âœ— [EMIT] Error emitting {event} to org_{organization_id}: {e}")  # Debug print
        logger.error(f"âœ— [EMIT] Error emitting {event} to org_{organization_id}: {e}", exc_info=True)
        logging.error(f"âœ— [EMIT] Error emitting {event} to org_{organization_id}: {e}", exc_info=True)  # Direct logging

# === GÃœVENLÄ°K YARDIMCI FONKSÄ°YONLARI (AynÄ± kaldÄ±) ===
_mongo_client = None; _mongo_db = None
async def ensure_db_connection(request: Request):
    global _mongo_client, _mongo_db; db = getattr(request.app, 'db', None)
    if db is None and _mongo_db is None:
        mongo_url = os.environ.get('MONGO_URL'); db_name = os.environ.get('DB_NAME', 'royal_koltuk_dev')
        if not mongo_url: raise HTTPException(status_code=503, detail="Database connection not configured.")
        try:
            new_client = AsyncIOMotorClient(mongo_url, serverSelectionTimeoutMS=5000); await new_client.admin.command('ping')
            new_db = new_client[db_name]; _mongo_client = new_client; _mongo_db = new_db
            request.app.mongodb_client = new_client; request.app.db = new_db
            logging.info(f"MongoDB connection established (lazy initialization) to {db_name}")
        except Exception as e:
            logging.error(f"Failed to establish MongoDB connection: {e}"); raise HTTPException(status_code=503, detail="Database connection failed.")
    elif db is None and _mongo_db is not None:
        request.app.mongodb_client = _mongo_client; request.app.db = _mongo_db; db = _mongo_db
    try:
        client_to_check = getattr(request.app, 'mongodb_client', _mongo_client)
        if client_to_check: await client_to_check.admin.command('ping')
    except Exception as e:
        logging.warning(f"MongoDB connection check failed: {e}, reconnecting..."); _mongo_client = None; _mongo_db = None; await ensure_db_connection(request) 
async def get_db(request: Request):
    await ensure_db_connection(request); db = getattr(request.app, 'db', None)
    if db is None: raise HTTPException(status_code=503, detail="Database connection failed.")
    return db
async def get_db_from_request(request: Request):
    await ensure_db_connection(request); db = getattr(request.app, 'db', None)
    if db is None: raise HTTPException(status_code=503, detail="Database connection failed.")
    return db
def verify_password(plain_password, hashed_password): return pwd_context.verify(plain_password, hashed_password)
def get_password_hash(password): return pwd_context.hash(password)
def create_access_token(data: dict, expires_delta: Optional[timedelta] = None):
    to_encode = data.copy()
    if expires_delta: expire = datetime.now(timezone.utc) + expires_delta
    else: expire = datetime.now(timezone.utc) + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
    to_encode.update({"exp": expire}); encoded_jwt = jwt.encode(to_encode, SECRET_KEY, algorithm=ALGORITHM)
    return encoded_jwt
async def get_user_from_db(request: Request, username: str, db=None):
    if db is None:
        await ensure_db_connection(request); db = getattr(request.app, 'db', None)
        if db is None: raise HTTPException(status_code=503, detail="Database connection failed.")
    user = await db.users.find_one({"username": username}, {"_id": 0})
    if user:
        try: return UserInDB(**user)
        except Exception as e: logging.warning(f"KullanÄ±cÄ± veritabanÄ±nda, ancak UserInDB modeline uymuyor: {e}"); return None
    return None
async def get_current_user(request: Request, token: str = Depends(oauth2_scheme), db = Depends(get_db)):
    credentials_exception = HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Could not validate credentials", headers={"WWW-Authenticate": "Bearer"})
    try:
        payload = jwt.decode(token, SECRET_KEY, algorithms=[ALGORITHM]); username: str = payload.get("sub")
        if username is None: raise credentials_exception
    except JWTError: raise credentials_exception
    user = await get_user_from_db(request, username, db=db) 
    if user is None: raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="User not found")
    return user

# --- SMS FONKSÄ°YONU (AynÄ± kaldÄ±) ---
def build_sms_message(template: str, company_name: str, customer_name: str, date: str, time: str, service: str, support_phone: str, custom_text: str = "") -> str:
    """SMS ÅŸablonunu doldurur. Zorunlu alanlar silinemez."""
    # Default template yoksa standart mesaj
    if not template:
        base = f"SayÄ±n {customer_name},\n\n{company_name} randevunuz:\n{date} - {time}\nHizmet: {service}\n\n"
        if custom_text:
            base += f"{custom_text}\n\n"
        base += f"Bilgi: {support_phone}"
        return base
    
    # Template'i doldur (Ã¶zelleÅŸtirilebilir alan varsa ekle)
    message = template
    message = message.replace("{MUSTERI_ADI}", customer_name)
    message = message.replace("{ISLETME_ADI}", company_name)
    message = message.replace("{TARIH}", date)
    message = message.replace("{SAAT}", time)
    message = message.replace("{HIZMET}", service)
    message = message.replace("{TELEFON}", support_phone)
    
    if custom_text and "{OZEL_MESAJ}" in message:
        message = message.replace("{OZEL_MESAJ}", custom_text)
    
    return message

def send_sms(to_phone: str, message: str):
    try:
        if not SMS_ENABLED: logging.info("SMS sending is disabled via SMS_ENABLED env. Skipping."); return True
        clean_phone = re.sub(r'\D', '', to_phone); 
        if clean_phone.startswith('90'): clean_phone = clean_phone[2:]
        if clean_phone.startswith('0'): clean_phone = clean_phone[1:]
        if not clean_phone.startswith('5') or len(clean_phone) != 10: logging.error(f"Invalid Turkish phone number format: {to_phone} -> {clean_phone}"); return False
        
        sanitized = re.sub(r"\s+", " ", message).strip(); MAX_LEN = 480
        if len(sanitized) > MAX_LEN: sanitized = sanitized[:MAX_LEN]
            
        api_url = "https://api.iletimerkezi.com/v1/send-sms/get/"
        params = {
            'key': ILETIMERKEZI_API_KEY, 'hash': ILETIMERKEZI_HASH, 'text': sanitized,
            'receipents': clean_phone, 'sender': ILETIMERKEZI_SENDER, 
            'iys': '1', 'iysList': 'BIREYSEL'
        }
        response = requests.get(api_url, params=params, timeout=10)
        try:
            root = ET.fromstring(response.text); status_code = root.find('.//status/code').text
            status_message = root.find('.//status/message').text
            if status_code == '200': logging.info(f"SMS sent successfully to {clean_phone} (Title: {ILETIMERKEZI_SENDER})."); return True
            else: logging.error(f"SMS failed to {clean_phone} (Title: {ILETIMERKEZI_SENDER}). Code: {status_code}, Message: {status_message}"); return False
        except ET.ParseError as e:
            logging.error(f"Failed to parse Ä°letimerkezi response (status={response.status_code}): {response.text} | Error: {str(e)}"); return False
    except Exception as e:
        logging.error(f"Failed to send SMS to {to_phone}: {str(e)}"); return False

# === YARDIMCI FONKSÄ°YONLAR ===
def slugify(text: str) -> str:
    """TÃ¼rkÃ§e karakterleri dÃ¶nÃ¼ÅŸtÃ¼rerek URL-friendly slug oluÅŸturur"""
    turkish_map = {
        'Ä±': 'i', 'Ä°': 'i', 'ÄŸ': 'g', 'Äž': 'g', 'Ã¼': 'u', 'Ãœ': 'u',
        'ÅŸ': 's', 'Åž': 's', 'Ã¶': 'o', 'Ã–': 'o', 'Ã§': 'c', 'Ã‡': 'c'
    }
    text = text.lower()
    for turkish_char, latin_char in turkish_map.items():
        text = text.replace(turkish_char, latin_char)
    text = re.sub(r'[^a-z0-9]+', '', text)
    return text

# === AUDIT LOG HELPER ===
def clean_dict_for_audit(data: Optional[dict]) -> Optional[dict]:
    """MongoDB ObjectID'lerini temizle"""
    if not data:
        return data
    cleaned = {}
    for key, value in data.items():
        if key == '_id':
            continue  # MongoDB _id'yi atla
        if isinstance(value, dict):
            cleaned[key] = clean_dict_for_audit(value)
        elif isinstance(value, list):
            cleaned[key] = [clean_dict_for_audit(item) if isinstance(item, dict) else item for item in value]
        else:
            cleaned[key] = value
    return cleaned

async def create_audit_log(
    db,
    organization_id: str,
    user_id: str,
    user_full_name: str,
    action: str,
    resource_type: str,
    resource_id: str,
    old_value: Optional[dict] = None,
    new_value: Optional[dict] = None,
    ip_address: Optional[str] = None
):
    """Denetim gÃ¼nlÃ¼ÄŸÃ¼ kaydÄ± oluÅŸtur"""
    try:
        # Clean values
        cleaned_old = clean_dict_for_audit(old_value)
        cleaned_new = clean_dict_for_audit(new_value)
        
        audit_log = AuditLog(
            organization_id=organization_id,
            user_id=user_id,
            user_full_name=user_full_name,
            action=action,
            resource_type=resource_type,
            resource_id=resource_id,
            old_value=cleaned_old,
            new_value=cleaned_new,
            ip_address=ip_address
        )
        doc = audit_log.model_dump()
        doc['timestamp'] = doc['timestamp'].isoformat()
        await db.audit_logs.insert_one(doc)
        logger.info(f"Audit log created: {action} {resource_type} by {user_id}")
    except Exception as e:
        logger.error(f"Failed to create audit log: {e}")

# === VERÄ° MODELLERÄ° (AynÄ± kaldÄ±) ===
class User(BaseModel):
    username: str; full_name: Optional[str] = None; organization_id: str = Field(default_factory=lambda: str(uuid.uuid4())); role: str = "admin"; slug: Optional[str] = None; permitted_service_ids: List[str] = [] 
class UserInDB(User): hashed_password: str
class UserCreate(BaseModel): username: str; password: str; full_name: Optional[str] = None; organization_name: Optional[str] = None; support_phone: Optional[str] = None; sector: Optional[str] = None
class Token(BaseModel): access_token: str; token_type: str
class Service(BaseModel):
    model_config = ConfigDict(extra="ignore"); organization_id: str; id: str = Field(default_factory=lambda: str(uuid.uuid4())); name: str; price: float; created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
class ServiceCreate(BaseModel): name: str; price: float
class ServiceUpdate(BaseModel): name: Optional[str] = None; price: Optional[float] = None
class Appointment(BaseModel):
    model_config = ConfigDict(extra="ignore"); organization_id: str; id: str = Field(default_factory=lambda: str(uuid.uuid4())); customer_name: str; phone: str; service_id: str; service_name: str; service_price: float; appointment_date: str; appointment_time: str; notes: str = ""; status: str = "Bekliyor"; staff_member_id: Optional[str] = None; created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc)); completed_at: Optional[str] = None
class AppointmentCreate(BaseModel):
    customer_name: str; phone: str; service_id: str; appointment_date: str; appointment_time: str; notes: str = ""; staff_member_id: Optional[str] = None
class AppointmentUpdate(BaseModel):
    customer_name: Optional[str] = None; phone: Optional[str] = None; address: Optional[str] = None; service_id: Optional[str] = None; appointment_date: Optional[str] = None; appointment_time: Optional[str] = None; notes: Optional[str] = None; status: Optional[str] = None; staff_member_id: Optional[str] = None
class Transaction(BaseModel):
    model_config = ConfigDict(extra="ignore"); organization_id: str; id: str = Field(default_factory=lambda: str(uuid.uuid4())); appointment_id: str; customer_name: str; service_name: str; amount: float; date: str; created_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
class TransactionUpdate(BaseModel): amount: float
class Settings(BaseModel):
    model_config = ConfigDict(extra="ignore"); organization_id: str; id: str = Field(default_factory=lambda: str(uuid.uuid4())); work_start_hour: int = 7; work_end_hour: int = 3; appointment_interval: int = 30
    company_name: str = "Ä°ÅŸletmeniz"; support_phone: str = "05000000000"; feedback_url: Optional[str] = None; slug: Optional[str] = None; customer_can_choose_staff: bool = False
    logo_url: Optional[str] = None; sms_reminder_hours: float = 1.0; sector: Optional[str] = None; admin_provides_service: bool = True
    # SMS Templates (Ã¶zelleÅŸtirilebilir metinler)
    sms_confirmation_template: Optional[str] = None
    sms_cancellation_template: Optional[str] = None
    sms_completion_template: Optional[str] = None
    sms_reminder_template: Optional[str] = None

class AuditLog(BaseModel):
    """Denetim gÃ¼nlÃ¼ÄŸÃ¼ modeli - Kritik iÅŸlemleri kaydeder"""
    model_config = ConfigDict(extra="ignore")
    id: str = Field(default_factory=lambda: str(uuid.uuid4()))
    organization_id: str
    user_id: str  # username
    user_full_name: str
    action: str  # CREATE, UPDATE, DELETE
    resource_type: str  # APPOINTMENT, SETTINGS, CUSTOMER, SERVICE, STAFF
    resource_id: str
    old_value: Optional[dict] = None
    new_value: Optional[dict] = None
    timestamp: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    ip_address: Optional[str] = None

# === GÃœVENLÄ°K API ENDPOINT'LERÄ° ===
@api_router.post("/register", response_model=User)
@rate_limit(LIMITS['register']) 
async def register_user(request: Request, user_in: UserCreate, db = Depends(get_db)):
    existing_user = await get_user_from_db(request, user_in.username, db=db)
    if existing_user: raise HTTPException(status_code=status.HTTP_400_BAD_REQUEST, detail="This username is already registered.")
    
    # Yeni organization ID oluÅŸtur
    new_org_id = str(uuid.uuid4())
    hashed_password = get_password_hash(user_in.password)
    
    # Slug oluÅŸtur (organization_name'den)
    base_slug = slugify(user_in.organization_name or user_in.username)
    unique_slug = base_slug
    
    # Slug benzersizlik kontrolÃ¼
    slug_counter = 1
    while await db.users.find_one({"slug": unique_slug}):
        unique_slug = f"{base_slug}{str(uuid.uuid4())[:4]}"
        slug_counter += 1
        if slug_counter > 10:  # Sonsuz dÃ¶ngÃ¼yÃ¼ Ã¶nle
            unique_slug = f"{base_slug}{str(uuid.uuid4())[:8]}"
            break
    
    # User kaydÄ±nÄ± oluÅŸtur
    user_db_data = user_in.model_dump(exclude={"organization_name", "support_phone"})
    user_db = UserInDB(**user_db_data, hashed_password=hashed_password, organization_id=new_org_id, role="admin", slug=unique_slug, permitted_service_ids=[])
    await db.users.insert_one(user_db.model_dump())
    
    # Bu kullanÄ±cÄ± iÃ§in varsayÄ±lan Settings oluÅŸtur (kayÄ±t bilgileriyle)
    default_settings = Settings(
        organization_id=new_org_id,
        company_name=user_in.organization_name or "Ä°ÅŸletmeniz",
        support_phone=user_in.support_phone or "05000000000",
        slug=unique_slug,
        customer_can_choose_staff=False,
        sector=getattr(user_in, 'sector', None)
    )
    await db.settings.insert_one(default_settings.model_dump())
    
    # SektÃ¶r bazlÄ± default services ekle ve admin'e ata
    sector = getattr(user_in, 'sector', None)
    service_ids = []
    
    if sector and sector != "DiÄŸer/BoÅŸ":
        sector_services = {
            "KuafÃ¶r": [
                {"name": "SaÃ§ Kesimi", "price": 150},
                {"name": "SaÃ§ Boyama", "price": 300},
                {"name": "Sakal TraÅŸÄ±", "price": 80},
            ],
            "GÃ¼zellik Salonu": [
                {"name": "ManikÃ¼r", "price": 100},
                {"name": "PedikÃ¼r", "price": 120},
                {"name": "Cilt BakÄ±mÄ±", "price": 250},
                {"name": "KaÅŸ DizaynÄ±", "price": 80},
            ],
            "Masaj / SPA": [
                {"name": "Klasik Masaj", "price": 300},
                {"name": "Aromaterapi MasajÄ±", "price": 350},
                {"name": "Ä°sveÃ§ MasajÄ±", "price": 400},
            ],
            "Diyetisyen": [
                {"name": "Ä°lk DanÄ±ÅŸma", "price": 300},
                {"name": "Kontrol Muayenesi", "price": 200},
                {"name": "Diyet PlanÄ±", "price": 250},
            ],
            "Psikolog / DanÄ±ÅŸmanlÄ±k": [
                {"name": "Bireysel Terapi", "price": 500},
                {"name": "Ã‡ift Terapisi", "price": 700},
                {"name": "Aile DanÄ±ÅŸmanlÄ±ÄŸÄ±", "price": 600},
            ],
            "DiÅŸ Klinikleri": [
                {"name": "Muayene", "price": 200},
                {"name": "Dolgu", "price": 400},
                {"name": "DiÅŸ TemizliÄŸi", "price": 300},
                {"name": "Beyazlatma", "price": 1500},
            ],
        }
        
        services_to_add = sector_services.get(sector, [])
        for service_data in services_to_add:
            service_id = str(uuid.uuid4())
            service = Service(
                id=service_id,
                organization_id=new_org_id,
                **service_data
            )
            await db.services.insert_one(service.model_dump())
            service_ids.append(service_id)
    
    # Admin'e tÃ¼m hizmetleri ata
    if service_ids:
        await db.users.update_one(
            {"username": user_in.username},
            {"$set": {"permitted_service_ids": service_ids}}
        )
    
    return User(**user_db.model_dump())

@api_router.post("/token", response_model=Token)
@rate_limit(LIMITS['login']) 
async def login_for_access_token(request: Request, form_data: OAuth2PasswordRequestForm = Depends(), db = Depends(get_db)):
    try:
        user = await get_user_from_db(request, form_data.username, db=db)
        if not user or not verify_password(form_data.password, user.hashed_password):
            raise HTTPException(status_code=status.HTTP_401_UNAUTHORIZED, detail="Incorrect username or password", headers={"WWW-Authenticate": "Bearer"})
        access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)
        token_data = {"sub": user.username, "org_id": user.organization_id, "role": user.role}
        access_token = create_access_token(data=token_data, expires_delta=access_token_expires)
        return {"access_token": access_token, "token_type": "bearer"}
    except HTTPException: raise
    except Exception as e:
        logging.error(f"Login error: {type(e).__name__}: {str(e)}"); import traceback; logging.error(traceback.format_exc())
        raise HTTPException(status_code=status.HTTP_500_INTERNAL_SERVER_ERROR, detail="An error occurred during login. Please try again later.")

# === APPOINTMENTS ROUTES ===
@api_router.delete("/appointments/{appointment_id}")
async def delete_appointment(request: Request, appointment_id: str, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request); query = {"id": appointment_id, "organization_id": current_user.organization_id}
    
    # Get appointment before deleting (for audit log)
    appointment = await db.appointments.find_one(query, {"_id": 0})
    if not appointment:
        raise HTTPException(status_code=404, detail="Randevu bulunamadÄ±")
    
    result = await db.appointments.delete_one(query)
    
    # Audit log
    await create_audit_log(
        db=db,
        organization_id=current_user.organization_id,
        user_id=current_user.username,
        user_full_name=current_user.full_name or current_user.username,
        action="DELETE",
        resource_type="APPOINTMENT",
        resource_id=appointment_id,
        old_value=appointment,
        ip_address=request.client.host if request.client else None
    )
    
    # Emit WebSocket event for real-time update
    logger.info(f"About to emit appointment_deleted for org: {current_user.organization_id}")
    try:
        await emit_to_organization(
            current_user.organization_id,
            'appointment_deleted',
            {'appointment_id': appointment_id}
        )
        logger.info(f"Successfully emitted appointment_deleted for org: {current_user.organization_id}")
    except Exception as emit_error:
        logger.error(f"Failed to emit appointment_deleted: {emit_error}", exc_info=True)
    
    return {"message": "Randevu silindi"}

@api_router.put("/appointments/{appointment_id}", response_model=Appointment)
async def update_appointment(request: Request, appointment_id: str, appointment_update: AppointmentUpdate, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request); settings_data = await db.settings.find_one({"organization_id": current_user.organization_id})
    if not settings_data:
        default_settings = Settings(organization_id=current_user.organization_id); settings_data = default_settings.model_dump()
    company_name = settings_data.get("company_name", "Ä°ÅŸletmeniz"); support_phone = settings_data.get("support_phone", "Destek HattÄ±"); feedback_url = settings_data.get("feedback_url", "")
    query = {"id": appointment_id, "organization_id": current_user.organization_id}; appointment = await db.appointments.find_one(query, {"_id": 0})
    if not appointment: raise HTTPException(status_code=404, detail="Randevu bulunamadÄ±")
    update_data = {k: v for k, v in appointment_update.model_dump().items() if v is not None}
    # Tarih/saat veya personel deÄŸiÅŸikliÄŸi varsa Ã§akÄ±ÅŸma kontrolÃ¼ yap
    if 'appointment_date' in update_data or 'appointment_time' in update_data or 'staff_member_id' in update_data:
        check_date = update_data.get('appointment_date', appointment['appointment_date'])
        check_time = update_data.get('appointment_time', appointment['appointment_time'])
        check_staff = update_data.get('staff_member_id', appointment.get('staff_member_id'))
        
        existing_query = {
            "organization_id": current_user.organization_id,
            "id": {"$ne": appointment_id},
            "staff_member_id": check_staff,
            "appointment_date": check_date,
            "appointment_time": check_time,
            "status": {"$ne": "Ä°ptal"}
        }
        existing = await db.appointments.find_one(existing_query)
        if existing:
            raise HTTPException(
                status_code=400,
                detail=f"Bu personelin {check_date} tarihinde {check_time} saatinde zaten bir randevusu var. LÃ¼tfen baÅŸka bir saat seÃ§in."
            )
    if 'service_id' in update_data:
        service_query = {"id": update_data['service_id'], "organization_id": current_user.organization_id}; service = await db.services.find_one(service_query, {"_id": 0})
        if service: update_data['service_name'] = service['name']; update_data['service_price'] = service['price']
    new_status = update_data.get('status'); old_status = appointment['status']
    if new_status == 'TamamlandÄ±' and old_status != 'TamamlandÄ±':
        update_data['completed_at'] = datetime.now(timezone.utc).isoformat()
        transaction = Transaction(organization_id=current_user.organization_id, appointment_id=appointment_id, customer_name=appointment['customer_name'], service_name=appointment['service_name'], amount=appointment['service_price'], date=appointment['appointment_date'])
        trans_doc = transaction.model_dump(); trans_doc['created_at'] = trans_doc['created_at'].isoformat()
        await db.transactions.insert_one(trans_doc)
        try:
            # Tamamlanma SMS'i - Sade ve kÄ±sa
            sms_message = (
                f"SayÄ±n {appointment['customer_name']},\n\n"
                f"{company_name} hizmetiniz tamamlandÄ±.\n\n"
                f"Tarih: {appointment['appointment_date']}\n"
                f"Hizmet: {appointment['service_name']}\n\n"
            )
            if feedback_url: 
                sms_message += f"Geri bildirim: {feedback_url}\n\n"
            sms_message += f"Bilgi: {support_phone}"
            send_sms(appointment['phone'], sms_message)
        except Exception as e: logging.error(f"TamamlandÄ± SMS'i gÃ¶nderilirken hata oluÅŸtu: {e}")
    elif new_status == 'Ä°ptal' and old_status != 'Ä°ptal':
        try:
            # Ä°ptal SMS'i - Sade ve kÄ±sa
            sms_message = (
                f"SayÄ±n {appointment['customer_name']},\n\n"
                f"{company_name} randevunuz iptal edildi.\n\n"
                f"Tarih: {appointment['appointment_date']}\n"
                f"Saat: {appointment['appointment_time']}\n\n"
                f"Bilgi: {support_phone}"
            )
            send_sms(appointment['phone'], sms_message)
        except Exception as e: logging.error(f"Ä°ptal SMS'i gÃ¶nderilirken hata oluÅŸtu: {e}")
    if update_data: await db.appointments.update_one(query, {"$set": update_data})
    updated_appointment = await db.appointments.find_one(query, {"_id": 0})
    if isinstance(updated_appointment['created_at'], str): updated_appointment['created_at'] = datetime.fromisoformat(updated_appointment['created_at'])
    
    # Audit log
    await create_audit_log(
        db=db,
        organization_id=current_user.organization_id,
        user_id=current_user.username,
        user_full_name=current_user.full_name or current_user.username,
        action="UPDATE",
        resource_type="APPOINTMENT",
        resource_id=appointment_id,
        old_value=appointment,
        new_value=updated_appointment,
        ip_address=request.client.host if request.client else None
    )
    
    # Emit WebSocket event for real-time update
    # Convert datetime to ISO format if it's a datetime object
    # make_json_serializable function will handle this, but we can also do it explicitly
    if isinstance(updated_appointment.get('created_at'), datetime):
        updated_appointment['created_at'] = updated_appointment['created_at'].isoformat()
    logger.info(f"About to emit appointment_updated for org: {current_user.organization_id}")
    try:
        await emit_to_organization(
            current_user.organization_id,
            'appointment_updated',
            {'appointment': updated_appointment}
        )
        logger.info(f"Successfully emitted appointment_updated for org: {current_user.organization_id}")
    except Exception as emit_error:
        logger.error(f"Failed to emit appointment_updated: {emit_error}", exc_info=True)
    
    return updated_appointment

@api_router.get("/appointments/{appointment_id}", response_model=Appointment)
async def get_appointment(request: Request, appointment_id: str, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request)
    query = {"id": appointment_id, "organization_id": current_user.organization_id}
    appointment = await db.appointments.find_one(query, {"_id": 0})
    if not appointment: raise HTTPException(status_code=404, detail="Randevu bulunamadÄ±")
    if isinstance(appointment['created_at'], str): appointment['created_at'] = datetime.fromisoformat(appointment['created_at'])
    return appointment

@api_router.post("/appointments", response_model=Appointment)
async def create_appointment(request: Request, appointment: AppointmentCreate, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request); service_query = {"id": appointment.service_id, "organization_id": current_user.organization_id}
    service = await db.services.find_one(service_query, {"_id": 0})
    if not service: raise HTTPException(status_code=404, detail="Hizmet bulunamadÄ±")
    
    # PERSONEL KONTROL: Staff ise sadece kendi hizmetlerine randevu alabilir
    if current_user.role == "staff":
        if service["id"] not in current_user.permitted_service_ids:
            raise HTTPException(status_code=403, detail="Bu hizmete randevu alma yetkiniz yok")
    
    # AynÄ± personelin aynÄ± saatte baÅŸka randevusu olup olmadÄ±ÄŸÄ±nÄ± kontrol et
    existing_query = {
        "organization_id": current_user.organization_id,
        "staff_member_id": appointment.staff_member_id,
        "appointment_date": appointment.appointment_date,
        "appointment_time": appointment.appointment_time,
        "status": {"$ne": "Ä°ptal"}
    }
    existing = await db.appointments.find_one(existing_query)
    if existing:
        raise HTTPException(
            status_code=400,
            detail=f"Bu personelin {appointment.appointment_date} tarihinde {appointment.appointment_time} saatinde zaten bir randevusu var. LÃ¼tfen baÅŸka bir saat seÃ§in."
        )
    appointment_data = appointment.model_dump(); appointment_data['service_name'] = service['name']; appointment_data['service_price'] = service['price']
    try:
        turkey_tz = ZoneInfo("Europe/Istanbul"); now = datetime.now(turkey_tz); dt_str = f"{appointment.appointment_date} {appointment.appointment_time}"
        naive_dt = datetime.strptime(dt_str, "%Y-%m-%d %H:%M"); appointment_dt = naive_dt.replace(tzinfo=turkey_tz)
        completion_threshold = appointment_dt + timedelta(hours=1)
        if now >= completion_threshold: appointment_data['status'] = 'TamamlandÄ±'; appointment_data['completed_at'] = datetime.now(timezone.utc).isoformat()
        else: appointment_data['status'] = 'Bekliyor'
    except (ValueError, TypeError) as e: logging.warning(f"Randevu durumu ayarlanÄ±rken tarih hatasÄ±: {e}"); appointment_data['status'] = 'Bekliyor'
    appointment_obj = Appointment(**appointment_data, organization_id=current_user.organization_id)
    doc = appointment_obj.model_dump(); doc['created_at'] = doc['created_at'].isoformat()
    await db.appointments.insert_one(doc)
    
    if appointment_obj.status == 'TamamlandÄ±':
        transaction = Transaction(organization_id=current_user.organization_id, appointment_id=appointment_obj.id, customer_name=appointment_obj.customer_name, service_name=appointment_obj.service_name, amount=appointment_obj.service_price, date=appointment_obj.appointment_date)
        trans_doc = transaction.model_dump(); trans_doc['created_at'] = trans_doc['created_at'].isoformat()
        await db.transactions.insert_one(trans_doc)

    settings_data = await db.settings.find_one({"organization_id": current_user.organization_id})
    if not settings_data:
        default_settings = Settings(organization_id=current_user.organization_id); settings_data = default_settings.model_dump()
    company_name = settings_data.get("company_name", "Ä°ÅŸletmeniz")
    support_phone = settings_data.get("support_phone", "Destek HattÄ±")
    
    # SMS Template kullan (Ã¶zelleÅŸtirilmiÅŸse)
    template = settings_data.get("sms_confirmation_template")
    if template:
        sms_message = build_sms_message(
            template, company_name, appointment.customer_name,
            appointment.appointment_date, appointment.appointment_time,
            service['name'], support_phone
        )
    else:
        # Default sade mesaj
        sms_message = (
            f"SayÄ±n {appointment.customer_name},\n\n"
            f"{company_name} randevunuz onaylandÄ±.\n\n"
            f"Tarih: {appointment.appointment_date}\n"
            f"Saat: {appointment.appointment_time}\n"
            f"Hizmet: {service['name']}\n\n"
            f"Bilgi: {support_phone}"
        )
    
    send_sms(appointment.phone, sms_message)
    
    # Audit log
    await create_audit_log(
        db=db,
        organization_id=current_user.organization_id,
        user_id=current_user.username,
        user_full_name=current_user.full_name or current_user.username,
        action="CREATE",
        resource_type="APPOINTMENT",
        resource_id=appointment_obj.id,
        new_value=doc,
        ip_address=request.client.host if request.client else None
    )
    
    # Emit WebSocket event for real-time update
    # Use appointment_obj.model_dump() instead of doc to avoid MongoDB _id issues
    appointment_for_emit = appointment_obj.model_dump()
    appointment_for_emit['created_at'] = appointment_for_emit['created_at'].isoformat()
    logger.info(f"About to emit appointment_created for org: {current_user.organization_id}")
    try:
        await emit_to_organization(
            current_user.organization_id,
            'appointment_created',
            {'appointment': appointment_for_emit}
        )
        logger.info(f"Successfully emitted appointment_created for org: {current_user.organization_id}")
    except Exception as emit_error:
        logger.error(f"Failed to emit appointment_created: {emit_error}", exc_info=True)
    
    return appointment_obj

@api_router.get("/appointments", response_model=List[Appointment])
async def get_appointments(
    request: Request, date: Optional[str] = None, status: Optional[str] = None, search: Optional[str] = None, current_user: UserInDB = Depends(get_current_user)
):
    db = await get_db_from_request(request)
    query = {"organization_id": current_user.organization_id}
    
    # Personel sadece kendine atanan randevularÄ± gÃ¶rebilir
    if current_user.role == "staff":
        query['staff_member_id'] = current_user.username
    
    if date: query['appointment_date'] = date
    if status: query['status'] = status
    if search:
        query['$or'] = [
            {'customer_name': {'$regex': search, '$options': 'i'}},
            {'phone': {'$regex': search, '$options': 'i'}}
        ]
    
    appointments_from_db = await db.appointments.find(query, {"_id": 0}).to_list(1000)
    try:
        turkey_tz = ZoneInfo("Europe/Istanbul"); now = datetime.now(turkey_tz)
    except Exception:
        turkey_tz = timezone(timedelta(hours=3)); now = datetime.now(turkey_tz)
    ids_to_update = []; transactions_to_create = [] 
    for appt in appointments_from_db:
        if isinstance(appt.get('created_at'), str): appt['created_at'] = datetime.fromisoformat(appt['created_at'])
        if appt.get('status') == 'Bekliyor':
            try:
                dt_str = f"{appt['appointment_date']} {appt['appointment_time']}"
                naive_dt = datetime.strptime(dt_str, "%Y-%m-%d %H:%M"); appointment_dt = naive_dt.replace(tzinfo=turkey_tz)
                completion_threshold = appointment_dt + timedelta(hours=1)
                if now >= completion_threshold:
                    appt['status'] = 'TamamlandÄ±'; completed_at_iso = datetime.now(timezone.utc).isoformat()
                    appt['completed_at'] = completed_at_iso; ids_to_update.append(appt['id'])
                    transaction = Transaction(organization_id=current_user.organization_id, appointment_id=appt['id'], customer_name=appt['customer_name'], service_name=appt['service_name'], amount=appt['service_price'], date=appt['appointment_date'])
                    trans_doc = transaction.model_dump(); trans_doc['created_at'] = trans_doc['created_at'].isoformat()
                    transactions_to_create.append(trans_doc)
            except (ValueError, TypeError) as e: logging.warning(f"Randevu {appt['id']} iÃ§in tarih ayrÄ±ÅŸtÄ±rÄ±lamadÄ±: {e}")
    if ids_to_update:
        await db.appointments.update_many({"organization_id": current_user.organization_id, "id": {"$in": ids_to_update}}, {"$set": {"status": "TamamlandÄ±", "completed_at": datetime.now(timezone.utc).isoformat()}})
    if transactions_to_create:
        await db.transactions.insert_many(transactions_to_create)
    return appointments_from_db

# === SERVICES ROUTES ===
@api_router.delete("/services/{service_id}")
async def delete_service(request: Request, service_id: str, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin silebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); query = {"id": service_id, "organization_id": current_user.organization_id}
    result = await db.services.delete_one(query)
    if result.deleted_count == 0: raise HTTPException(status_code=404, detail="Hizmet bulunamadÄ±")
    return {"message": "Hizmet silindi"}

@api_router.put("/services/{service_id}", response_model=Service)
async def update_service(request: Request, service_id: str, service_update: ServiceUpdate, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin gÃ¼ncelleyebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); query = {"id": service_id, "organization_id": current_user.organization_id}
    service = await db.services.find_one(query, {"_id": 0})
    if not service: raise HTTPException(status_code=404, detail="Hizmet bulunamadÄ±")
    update_data = {k: v for k, v in service_update.model_dump().items() if v is not None}
    if update_data: await db.services.update_one(query, {"$set": update_data})
    updated_service = await db.services.find_one(query, {"_id": 0})
    if isinstance(updated_service['created_at'], str): updated_service['created_at'] = datetime.fromisoformat(updated_service['created_at'])
    return updated_service

@api_router.get("/services/{service_id}", response_model=Service)
async def get_service(request: Request, service_id: str, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request); query = {"id": service_id, "organization_id": current_user.organization_id}
    service = await db.services.find_one(query, {"_id": 0})
    if not service: raise HTTPException(status_code=404, detail="Hizmet bulunamadÄ±")
    if isinstance(service['created_at'], str): service['created_at'] = datetime.fromisoformat(service['created_at'])
    return service

@api_router.post("/services", response_model=Service)
async def create_service(request: Request, service: ServiceCreate, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin ekleyebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); service_obj = Service(**service.model_dump(), organization_id=current_user.organization_id)
    doc = service_obj.model_dump(); doc['created_at'] = doc['created_at'].isoformat()
    await db.services.insert_one(doc); return service_obj

@api_router.get("/services", response_model=List[Service])
async def get_services(request: Request, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request); query = {"organization_id": current_user.organization_id}
    services = await db.services.find(query, {"_id": 0}).to_list(1000)
    for service in services:
        if isinstance(service['created_at'], str): service['created_at'] = datetime.fromisoformat(service['created_at'])
    return services

# === TRANSACTIONS ROUTES ===
@api_router.get("/transactions", response_model=List[Transaction])
async def get_transactions(request: Request, start_date: Optional[str] = None, end_date: Optional[str] = None, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin gÃ¶rebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); query = {"organization_id": current_user.organization_id}
    if start_date and end_date: query['date'] = {'$gte': start_date, '$lte': end_date}
    elif start_date: query['date'] = {'$gte': start_date}
    elif end_date: query['date'] = {'$lte': end_date}
    transactions = await db.transactions.find(query, {"_id": 0}).to_list(1000)
    for transaction in transactions:
        if isinstance(transaction['created_at'], str): transaction['created_at'] = datetime.fromisoformat(transaction['created_at'])
    return transactions

@api_router.put("/transactions/{transaction_id}", response_model=Transaction)
async def update_transaction(request: Request, transaction_id: str, transaction_update: TransactionUpdate, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin gÃ¼ncelleyebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); query = {"id": transaction_id, "organization_id": current_user.organization_id}
    transaction = await db.transactions.find_one(query, {"_id": 0})
    if not transaction: raise HTTPException(status_code=404, detail="Ä°ÅŸlem bulunamadÄ±")
    await db.transactions.update_one(query, {"$set": {"amount": transaction_update.amount}})
    updated_transaction = await db.transactions.find_one(query, {"_id": 0})
    if isinstance(updated_transaction['created_at'], str): updated_transaction['created_at'] = datetime.fromisoformat(updated_transaction['created_at'])
    return updated_transaction

@api_router.delete("/transactions/{transaction_id}")
async def delete_transaction(request: Request, transaction_id: str, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin silebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); query = {"id": transaction_id, "organization_id": current_user.organization_id}
    result = await db.transactions.delete_one(query)
    if result.deleted_count == 0: raise HTTPException(status_code=404, detail="Ä°ÅŸlem bulunamadÄ±")
    return {"message": "Ä°ÅŸlem silindi"}

# === DASHBOARD STATS ===
@api_router.get("/stats/dashboard")
async def get_dashboard_stats(request: Request, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin gÃ¶rebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request); turkey_tz = ZoneInfo("Europe/Istanbul"); today = datetime.now(turkey_tz).date().isoformat()
    base_query = {"organization_id": current_user.organization_id}
    today_appointments = await db.appointments.count_documents({**base_query, "appointment_date": today})
    today_completed = await db.appointments.count_documents({**base_query, "appointment_date": today, "status": "TamamlandÄ±"})
    today_transactions = await db.transactions.find({**base_query, "date": today}, {"_id": 0}).to_list(1000)
    today_income = sum(t['amount'] for t in today_transactions)
    week_start = (datetime.now(turkey_tz).date() - timedelta(days=7)).isoformat()
    week_transactions = await db.transactions.find({**base_query, "date": {"$gte": week_start}}, {"_id": 0}).to_list(1000)
    week_income = sum(t['amount'] for t in week_transactions)
    month_start = datetime.now(turkey_tz).date().replace(day=1).isoformat()
    month_transactions = await db.transactions.find({**base_query, "date": {"$gte": month_start}}, {"_id": 0}).to_list(1000)
    month_income = sum(t['amount'] for t in month_transactions)
    return {
        "today_appointments": today_appointments, "today_completed": today_completed, "today_income": today_income, "week_income": week_income, "month_income": month_income
    }

# === SETTINGS ROUTES ===
@api_router.get("/settings", response_model=Settings)
async def get_settings(request: Request, current_user: UserInDB = Depends(get_current_user)):
    # Personel okuyabilir, ama sadece admin gÃ¼ncelleyebilir
    db = await get_db_from_request(request); query = {"organization_id": current_user.organization_id}
    settings = await db.settings.find_one(query, {"_id": 0})
    if not settings:
        default_settings = Settings(organization_id=current_user.organization_id); await db.settings.insert_one(default_settings.model_dump())
        return default_settings
    return Settings(**settings)

@api_router.put("/settings", response_model=Settings)
async def update_settings(request: Request, settings: Settings, current_user: UserInDB = Depends(get_current_user)):
    # Sadece admin gÃ¼ncelleyebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    query = {"organization_id": current_user.organization_id}
    
    # Mevcut ayarlarÄ± al
    current_settings = await db.settings.find_one(query, {"_id": 0})
    
    update_data = settings.model_dump()
    update_data["organization_id"] = current_user.organization_id
    
    # EÄŸer company_name deÄŸiÅŸtiyse, yeni slug oluÅŸtur
    if current_settings and current_settings.get('company_name') != settings.company_name:
        # Yeni slug oluÅŸtur
        base_slug = slugify(settings.company_name)
        unique_slug = base_slug
        
        # Slug benzersizlik kontrolÃ¼
        slug_counter = 1
        while await db.users.find_one({"slug": unique_slug, "username": {"$ne": current_user.username}}):
            unique_slug = f"{base_slug}{str(uuid.uuid4())[:4]}"
            slug_counter += 1
            if slug_counter > 10:
                unique_slug = f"{base_slug}{str(uuid.uuid4())[:8]}"
                break
        
        # User'Ä±n slug'Ä±nÄ± gÃ¼ncelle
        await db.users.update_one(
            {"username": current_user.username},
            {"$set": {"slug": unique_slug}}
        )
        
        # Settings'e yeni slug'Ä± ekle
        update_data["slug"] = unique_slug
        
        logging.info(f"Company name changed. New slug: {unique_slug}")
    
    await db.settings.update_one(query, {"$set": update_data}, upsert=True)
    updated_settings = await db.settings.find_one(query, {"_id": 0})
    
    # Audit log
    await create_audit_log(
        db=db,
        organization_id=current_user.organization_id,
        user_id=current_user.username,
        user_full_name=current_user.full_name or current_user.username,
        action="UPDATE",
        resource_type="SETTINGS",
        resource_id=current_user.organization_id,
        old_value=current_settings,
        new_value=updated_settings,
        ip_address=request.client.host if request.client else None
    )
    
    return Settings(**updated_settings)

@api_router.post("/settings/logo")
async def upload_logo(request: Request, file: UploadFile = File(...), current_user: UserInDB = Depends(get_current_user)):
    """Logo upload endpoint"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    # File validation
    if not file.content_type.startswith('image/'):
        raise HTTPException(status_code=400, detail="Sadece resim dosyalarÄ± yÃ¼klenebilir")
    
    # File size check (2MB)
    file_content = await file.read()
    if len(file_content) > 2 * 1024 * 1024:
        raise HTTPException(status_code=400, detail="Dosya boyutu 2MB'dan bÃ¼yÃ¼k olamaz")
    
    # Save file to static directory
    static_dir = ROOT_DIR / "static" / "logos"
    static_dir.mkdir(parents=True, exist_ok=True)
    
    file_extension = file.filename.split('.')[-1]
    unique_filename = f"{current_user.organization_id}_{str(uuid.uuid4())[:8]}.{file_extension}"
    file_path = static_dir / unique_filename
    
    with open(file_path, "wb") as f:
        f.write(file_content)
    
    # Update settings with logo URL (with /api prefix for ingress routing)
    logo_url = f"/api/static/logos/{unique_filename}"
    
    db = await get_db_from_request(request)
    query = {"organization_id": current_user.organization_id}
    await db.settings.update_one(query, {"$set": {"logo_url": logo_url}}, upsert=True)
    
    return {"logo_url": logo_url, "message": "Logo baÅŸarÄ±yla yÃ¼klendi"}

# === USERS/PERSONEL LÄ°STESÄ° (Model D) ===
@api_router.get("/users")
async def get_users(request: Request, current_user: UserInDB = Depends(get_current_user)):
    """AynÄ± organization'daki tÃ¼m kullanÄ±cÄ±larÄ± listele (ÅŸifreler hariÃ§)"""
    db = await get_db_from_request(request)
    
    users = await db.users.find(
        {"organization_id": current_user.organization_id},
        {"_id": 0, "hashed_password": 0}  # Åžifreleri gizle
    ).to_list(1000)
    
    return users

# === STAFF/PERSONEL YÃ–NETÄ°MÄ° (Model D) ===
class StaffCreate(BaseModel):
    username: str
    password: str
    full_name: str

@api_router.post("/staff/add")
async def add_staff(request: Request, staff_data: StaffCreate, current_user: UserInDB = Depends(get_current_user)):
    """Admin, yeni personel ekleyebilir"""
    # Sadece admin ekleyebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    
    # KullanÄ±cÄ± adÄ± zaten var mÄ± kontrol et
    existing = await db.users.find_one({"username": staff_data.username})
    if existing:
        raise HTTPException(status_code=400, detail="Bu e-posta adresi zaten kayÄ±tlÄ±")
    
    # Yeni personel oluÅŸtur
    hashed_password = get_password_hash(staff_data.password)
    new_user = UserInDB(
        username=staff_data.username,
        full_name=staff_data.full_name,
        hashed_password=hashed_password,
        organization_id=current_user.organization_id,
        role="staff",  # Personel rolÃ¼
        slug=None,  # Personellerin slug'Ä± yok
        permitted_service_ids=[]  # BaÅŸlangÄ±Ã§ta boÅŸ
    )
    
    await db.users.insert_one(new_user.model_dump())
    
    return {"message": "Personel baÅŸarÄ±yla eklendi", "username": staff_data.username, "full_name": staff_data.full_name}

@api_router.delete("/staff/{staff_id}")
async def delete_staff(request: Request, staff_id: str, current_user: UserInDB = Depends(get_current_user)):
    """Admin, personel silebilir"""
    # Sadece admin silebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    
    # Personelin aynÄ± organization'da olduÄŸunu kontrol et
    staff = await db.users.find_one({"username": staff_id, "organization_id": current_user.organization_id})
    if not staff:
        raise HTTPException(status_code=404, detail="Personel bulunamadÄ± veya eriÅŸim yok")
    
    # Admin kendini silemez
    if staff.get("role") == "admin":
        raise HTTPException(status_code=400, detail="Admin kullanÄ±cÄ±larÄ± silinemez")
    
    # Personeli sil
    await db.users.delete_one({"username": staff_id, "organization_id": current_user.organization_id})
    
    return {"message": "Personel baÅŸarÄ±yla silindi"}

@api_router.put("/staff/{staff_id}/services")
async def update_staff_services(request: Request, staff_id: str, service_ids: List[str], current_user: UserInDB = Depends(get_current_user)):
    """Admin, personelin verebileceÄŸi hizmetleri gÃ¼ncelleyebilir"""
    # Sadece admin gÃ¼ncelleyebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    
    # Personelin aynÄ± organization'da olduÄŸunu kontrol et
    staff = await db.users.find_one({"username": staff_id, "organization_id": current_user.organization_id})
    if not staff:
        raise HTTPException(status_code=404, detail="Personel bulunamadÄ± veya eriÅŸim yok")
    
    # Personelin permitted_service_ids'ini gÃ¼ncelle
    await db.users.update_one(
        {"username": staff_id, "organization_id": current_user.organization_id},
        {"$set": {"permitted_service_ids": service_ids}}
    )
    
    return {"message": "Personel hizmetleri gÃ¼ncellendi", "staff_id": staff_id, "permitted_service_ids": service_ids}

# === CUSTOMERS ROUTES ===
@api_router.get("/customers")
async def get_customers(request: Request, current_user: UserInDB = Depends(get_current_user)):
    """TÃ¼m unique mÃ¼ÅŸterileri listele (organization bazlÄ±)"""
    db = await get_db_from_request(request)
    
    # TÃ¼m randevularÄ± Ã§ek
    appointments = await db.appointments.find(
        {"organization_id": current_user.organization_id},
        {"_id": 0}
    ).to_list(10000)
    
    # Unique mÃ¼ÅŸterileri grupla
    customer_map = {}
    for apt in appointments:
        phone = apt.get('phone')
        if phone and phone not in customer_map:
            customer_map[phone] = {
                "name": apt.get('customer_name', ''),
                "phone": phone,
                "total_appointments": 0,
                "completed_appointments": 0
            }
        
        if phone:
            customer_map[phone]['total_appointments'] += 1
            if apt.get('status') == 'TamamlandÄ±':
                customer_map[phone]['completed_appointments'] += 1
    
    # Liste olarak dÃ¶ndÃ¼r
    customers = list(customer_map.values())
    customers.sort(key=lambda x: x['total_appointments'], reverse=True)
    
    return customers

@api_router.delete("/customers/{phone}")
async def delete_customer(request: Request, phone: str, current_user: UserInDB = Depends(get_current_user)):
    """MÃ¼ÅŸteriyi ve TÃœM randevularÄ±nÄ± sil"""
    # Sadece admin silebilir
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    
    # MÃ¼ÅŸterinin tÃ¼m randevularÄ±nÄ± sil
    query = {"phone": phone, "organization_id": current_user.organization_id}
    
    # Get appointments before deleting (for audit log)
    appointments_to_delete = await db.appointments.find(query, {"_id": 0}).to_list(1000)
    
    result = await db.appointments.delete_many(query)
    
    if result.deleted_count == 0:
        raise HTTPException(status_code=404, detail="Bu telefon numarasÄ±na ait randevu bulunamadÄ±")
    
    # Transaction'larÄ± da sil (eÄŸer varsa)
    await db.transactions.delete_many(query)
    
    # Audit log
    await create_audit_log(
        db=db,
        organization_id=current_user.organization_id,
        user_id=current_user.username,
        user_full_name=current_user.full_name or current_user.username,
        action="DELETE",
        resource_type="CUSTOMER",
        resource_id=phone,
        old_value={"phone": phone, "appointments": appointments_to_delete, "count": result.deleted_count},
        ip_address=request.client.host if request.client else None
    )
    
    return {"message": f"MÃ¼ÅŸteri ve {result.deleted_count} randevu silindi", "deleted_appointments": result.deleted_count}

# === AUDIT LOGS ROUTES ===
@api_router.get("/audit-logs", response_model=List[AuditLog])
async def get_audit_logs(
    request: Request,
    start_date: Optional[str] = None,
    end_date: Optional[str] = None,
    user_id: Optional[str] = None,
    action: Optional[str] = None,
    resource_type: Optional[str] = None,
    current_user: UserInDB = Depends(get_current_user)
):
    """Denetim gÃ¼nlÃ¼klerini getir - Sadece admin"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    query = {"organization_id": current_user.organization_id}
    
    # Filters
    if user_id:
        query["user_id"] = user_id
    if action:
        query["action"] = action
    if resource_type:
        query["resource_type"] = resource_type
    if start_date or end_date:
        query["timestamp"] = {}
        if start_date:
            query["timestamp"]["$gte"] = start_date
        if end_date:
            query["timestamp"]["$lte"] = end_date
    
    # Get logs, sorted by timestamp descending
    logs = await db.audit_logs.find(query, {"_id": 0}).sort("timestamp", -1).to_list(500)
    
    # Convert timestamp strings back to datetime
    for log in logs:
        if isinstance(log.get('timestamp'), str):
            log['timestamp'] = datetime.fromisoformat(log['timestamp'])
    
    return logs

@api_router.get("/export/appointments")
async def export_appointments(request: Request, current_user: UserInDB = Depends(get_current_user)):
    """RandevularÄ± CSV formatÄ±nda export et"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    appointments = await db.appointments.find(
        {"organization_id": current_user.organization_id},
        {"_id": 0}
    ).sort("appointment_date", -1).to_list(10000)
    
    # CSV formatÄ±nda hazÄ±rla
    import csv
    import io
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Header
    writer.writerow([
        "Randevu ID", "MÃ¼ÅŸteri AdÄ±", "Telefon", "Tarih", "Saat",
        "Hizmet", "Personel", "Durum", "Fiyat", "Notlar", "OluÅŸturma Tarihi"
    ])
    
    # Data
    for apt in appointments:
        writer.writerow([
            apt.get('id', ''),
            apt.get('customer_name', ''),
            apt.get('phone', ''),
            apt.get('appointment_date', ''),
            apt.get('appointment_time', ''),
            apt.get('service_name', ''),
            apt.get('staff_member_name', 'AtanmadÄ±'),
            apt.get('status', ''),
            apt.get('price', 0),
            apt.get('notes', ''),
            str(apt.get('created_at', ''))
        ])
    
    output.seek(0)
    
    from fastapi.responses import StreamingResponse
    return StreamingResponse(
        iter([output.getvalue()]),
        media_type="text/csv",
        headers={"Content-Disposition": "attachment; filename=randevular.csv"}
    )

@api_router.get("/export/customers")
async def export_customers(request: Request, current_user: UserInDB = Depends(get_current_user)):
    """MÃ¼ÅŸterileri CSV formatÄ±nda export et"""
    if current_user.role != "admin":
        raise HTTPException(status_code=403, detail="Bu iÅŸlem iÃ§in yetkiniz yok")
    
    db = await get_db_from_request(request)
    
    # TÃ¼m randevularÄ± Ã§ek
    appointments = await db.appointments.find(
        {"organization_id": current_user.organization_id},
        {"_id": 0}
    ).to_list(10000)
    
    # Unique mÃ¼ÅŸterileri grupla
    customer_map = {}
    for apt in appointments:
        phone = apt.get('phone')
        if phone and phone not in customer_map:
            customer_map[phone] = {
                "name": apt.get('customer_name', ''),
                "phone": phone,
                "total_appointments": 0,
                "completed_appointments": 0,
                "last_appointment_date": apt.get('appointment_date', '')
            }
        
        if phone:
            customer_map[phone]['total_appointments'] += 1
            if apt.get('status') == 'TamamlandÄ±':
                customer_map[phone]['completed_appointments'] += 1
            # En son randevu tarihini gÃ¼ncelle
            if apt.get('appointment_date', '') > customer_map[phone]['last_appointment_date']:
                customer_map[phone]['last_appointment_date'] = apt.get('appointment_date', '')
    
    # CSV formatÄ±nda hazÄ±rla
    import csv
    import io
    
    output = io.StringIO()
    writer = csv.writer(output)
    
    # Header
    writer.writerow([
        "MÃ¼ÅŸteri AdÄ±", "Telefon", "Toplam Randevu",
        "Tamamlanan Randevu", "Son Randevu Tarihi"
    ])
    
    # Data
    customers = sorted(customer_map.values(), key=lambda x: x['total_appointments'], reverse=True)
    for customer in customers:
        writer.writerow([
            customer['name'],
            customer['phone'],
            customer['total_appointments'],
            customer['completed_appointments'],
            customer['last_appointment_date']
        ])
    
    output.seek(0)
    
    from fastapi.responses import StreamingResponse
    return StreamingResponse(
        iter([output.getvalue()]),
        media_type="text/csv",
        headers={"Content-Disposition": "attachment; filename=musteriler.csv"}
    )

@api_router.get("/customers/{phone}/history")
async def get_customer_history(request: Request, phone: str, current_user: UserInDB = Depends(get_current_user)):
    db = await get_db_from_request(request); query = {"phone": phone, "organization_id": current_user.organization_id}
    appointments = await db.appointments.find(query, {"_id": 0}).sort("appointment_date", -1).to_list(1000)
    for appointment in appointments:
        if isinstance(appointment['created_at'], str): appointment['created_at'] = datetime.fromisoformat(appointment['created_at'])
    total_completed = len([a for a in appointments if a['status'] == 'TamamlandÄ±'])
    return {"phone": phone, "total_appointments": len(appointments), "completed_appointments": total_completed, "appointments": appointments}

# === PUBLIC API ROUTES (TOKEN GEREKTÄ°RMEZ) ===
@api_router.get("/public/business/{slug}")
async def get_public_business(request: Request, slug: str):
    """Slug ile iÅŸletme bilgilerini, hizmetlerini, personellerini ve ayarlarÄ±nÄ± getir (Model D)"""
    db = await get_db_from_request(request)
    
    # Ä°lk Ã¶nce user'dan slug'Ä± bul (admin kullanÄ±cÄ±sÄ±)
    admin_user = await db.users.find_one({"slug": slug}, {"_id": 0})
    if not admin_user:
        raise HTTPException(status_code=404, detail="Ä°ÅŸletme bulunamadÄ±")
    
    organization_id = admin_user.get('organization_id')
    
    # Hizmetleri Ã§ek
    services = await db.services.find({"organization_id": organization_id}, {"_id": 0}).to_list(1000)
    
    # AyarlarÄ± Ã§ek
    settings = await db.settings.find_one({"organization_id": organization_id}, {"_id": 0})
    if not settings:
        # VarsayÄ±lan ayarlar
        settings = {
            "customer_can_choose_staff": False,
            "work_start_hour": 9,
            "work_end_hour": 18,
            "appointment_interval": 30,
            "company_name": admin_user.get('full_name', 'Ä°ÅŸletme'),
            "admin_provides_service": True
        }
    
    # TÃ¼m personelleri Ã§ek (SADECE gerekli alanlar - ÅžÄ°FRELER HARÄ°Ã‡!)
    staff_members = await db.users.find(
        {"organization_id": organization_id}, 
        {"_id": 0, "full_name": 1, "id": 1, "permitted_service_ids": 1, "username": 1, "role": 1}
    ).to_list(1000)
    
    # Admin hizmet vermiyorsa admin'i listeden Ã§Ä±kar
    if not settings.get('admin_provides_service', True):
        staff_members = [staff for staff in staff_members if staff.get('role') != 'admin']
    
    return {
        "business_name": settings.get('company_name', admin_user.get('full_name', 'Ä°ÅŸletme')),
        "logo_url": settings.get('logo_url'),
        "organization_id": organization_id,
        "services": services,
        "staff_members": staff_members,
        "settings": {
            "customer_can_choose_staff": settings.get('customer_can_choose_staff', False),
            "work_start_hour": settings.get('work_start_hour', 9),
            "work_end_hour": settings.get('work_end_hour', 18),
            "appointment_interval": settings.get('appointment_interval', 30)
        }
    }

@api_router.get("/public/availability/{organization_id}")
async def get_availability(request: Request, organization_id: str, service_id: str, date: str, staff_id: Optional[str] = None):
    """Model D: Personel bazlÄ± akÄ±llÄ± mÃ¼saitlik kontrolÃ¼"""
    db = await get_db_from_request(request)
    
    # EÄŸer mÃ¼ÅŸteri belirli bir personel seÃ§tiyse, sadece o personele bak
    if staff_id:
        staff_members = await db.users.find(
            {"organization_id": organization_id, "username": staff_id, "permitted_service_ids": {"$in": [service_id]}},
            {"_id": 0, "id": 1, "username": 1}
        ).to_list(1000)
        
        if not staff_members:
            return {"available_slots": [], "message": "SeÃ§ilen personel bu hizmeti veremiyor"}
    else:
        # O hizmeti verebilen TÃœM personelleri bul (Array iÃ§inde arama)
        staff_members = await db.users.find(
            {"organization_id": organization_id, "permitted_service_ids": {"$in": [service_id]}},
            {"_id": 0, "id": 1, "username": 1}
        ).to_list(1000)
        
        if not staff_members:
            # HiÃ§ personel yoksa veya hiÃ§biri bu hizmeti vermiyorsa boÅŸ dÃ¶n
            return {"available_slots": [], "message": "Bu hizmet iÃ§in uygun personel bulunamadÄ±"}
    
    # AyarlarÄ± al
    settings = await db.settings.find_one({"organization_id": organization_id}, {"_id": 0})
    if not settings:
        settings = {"work_start_hour": 9, "work_end_hour": 18, "appointment_interval": 30}
    
    work_start_hour = settings.get('work_start_hour', 9)
    work_end_hour = settings.get('work_end_hour', 18)
    appointment_interval = settings.get('appointment_interval', 30)
    
    # TÃ¼m olasÄ± saatleri oluÅŸtur
    all_slots = []
    currentHour = work_start_hour
    currentMinute = 0
    
    while True:
        if work_end_hour < work_start_hour:
            if currentHour == 24:
                currentHour = 0
            if currentHour == work_end_hour and currentMinute > 0:
                break
            if currentHour > work_end_hour and currentHour < work_start_hour:
                break
        else:
            if currentHour > work_end_hour:
                break
            if currentHour == work_end_hour and currentMinute > 0:
                break
        
        time = f"{str(currentHour).zfill(2)}:{str(currentMinute).zfill(2)}"
        all_slots.append(time)
        
        currentMinute += appointment_interval
        if currentMinute >= 60:
            currentMinute = 0
            currentHour += 1
    
    # KRÄ°TÄ°K: Personel aynÄ± anda sadece 1 mÃ¼ÅŸteriye hizmet verebilir
    # O hizmeti verebilen personellerin o tarihteki TÃœM randevularÄ±nÄ± Ã§ek (hangi hizmet olursa olsun)
    staff_ids = [staff['username'] for staff in staff_members]
    
    # Personellerin o gÃ¼n iÃ§in TÃœM randevularÄ±nÄ± al (tÃ¼m hizmetler dahil)
    all_staff_appointments = await db.appointments.find(
        {
            "organization_id": organization_id,
            "appointment_date": date,
            "status": {"$ne": "Ä°ptal"},
            "staff_member_id": {"$in": staff_ids}
        },
        {"_id": 0, "appointment_time": 1, "staff_member_id": 1, "service_name": 1}
    ).to_list(1000)
    
    logging.info(f"ðŸ” Service: {service_id}, Date: {date}")
    logging.info(f"ðŸ‘¥ Qualified staff: {len(staff_members)} - {staff_ids}")
    logging.info(f"ðŸ“… Total appointments for these staff: {len(all_staff_appointments)}")
    
    # Hangi saatlerde EN AZ BÄ°R personel mÃ¼sait?
    available_slots = []
    for slot in all_slots:
        # Bu saatte dolu olan personeller (hangi hizmet olursa olsun)
        busy_staff_at_slot = [appt['staff_member_id'] for appt in all_staff_appointments if appt['appointment_time'] == slot]
        busy_staff_unique = list(set(busy_staff_at_slot))  # Tekil personel ID'leri
        
        # EÄŸer TÃœM personeller dolu deÄŸilse, bu saat mÃ¼sait
        available_count = len(staff_members) - len(busy_staff_unique)
        if available_count > 0:
            available_slots.append(slot)
            logging.debug(f"â° Slot {slot}: {available_count}/{len(staff_members)} personel mÃ¼sait")
        else:
            logging.debug(f"ðŸš« Slot {slot}: TÃ¼m personeller dolu")
    
    logging.info(f"âœ… Available slots: {len(available_slots)}")
    return {"available_slots": available_slots}

@api_router.post("/public/appointments")
async def create_public_appointment(request: Request, appointment: AppointmentCreate, organization_id: str):
    """Model D: Public randevu oluÅŸtur - AkÄ±llÄ± personel atama"""
    db = await get_db_from_request(request)
    
    # Service'i bul
    service = await db.services.find_one({"id": appointment.service_id}, {"_id": 0})
    if not service:
        raise HTTPException(status_code=404, detail="Hizmet bulunamadÄ±")
    
    assigned_staff_id = None
    
    # AKILLI ATAMA MANTIÄžI
    if appointment.staff_member_id:
        # MÃ¼ÅŸteri belirli bir personel seÃ§ti
        # O personelin o saatte dolu olup olmadÄ±ÄŸÄ±nÄ± kontrol et
        existing = await db.appointments.find_one({
            "organization_id": organization_id,
            "staff_member_id": appointment.staff_member_id,
            "appointment_date": appointment.appointment_date,
            "appointment_time": appointment.appointment_time,
            "status": {"$ne": "Ä°ptal"}
        })
        if existing:
            raise HTTPException(
                status_code=400,
                detail="SeÃ§tiÄŸiniz personel bu saatte dolu. LÃ¼tfen baÅŸka bir saat veya personel seÃ§in."
            )
        assigned_staff_id = appointment.staff_member_id
    else:
        # MÃ¼ÅŸteri "Farketmez" seÃ§ti veya personel seÃ§imi yok
        # Bu hizmeti verebilen personellerden boÅŸ olanÄ± bul (Array iÃ§inde arama)
        qualified_staff = await db.users.find(
            {"organization_id": organization_id, "permitted_service_ids": {"$in": [appointment.service_id]}},
            {"_id": 0, "username": 1}
        ).to_list(1000)
        
        if not qualified_staff:
            raise HTTPException(
                status_code=400,
                detail="Bu hizmet iÃ§in uygun personel bulunamadÄ±"
            )
        
        # BoÅŸ personel bul
        for staff in qualified_staff:
            existing = await db.appointments.find_one({
                "organization_id": organization_id,
                "staff_member_id": staff['username'],
                "appointment_date": appointment.appointment_date,
                "appointment_time": appointment.appointment_time,
                "status": {"$ne": "Ä°ptal"}
            })
            if not existing:
                # Bu personel boÅŸ!
                assigned_staff_id = staff['username']
                break
        
        if not assigned_staff_id:
            raise HTTPException(
                status_code=400,
                detail="Bu saat dilimi doludur. LÃ¼tfen baÅŸka bir saat seÃ§in."
            )
    
    # Randevuyu oluÅŸtur
    appointment_data = appointment.model_dump()
    appointment_data['service_name'] = service['name']
    appointment_data['service_price'] = service['price']
    appointment_data['status'] = 'Bekliyor'
    appointment_data['staff_member_id'] = assigned_staff_id
    
    appointment_obj = Appointment(**appointment_data, organization_id=organization_id)
    doc = appointment_obj.model_dump()
    doc['created_at'] = doc['created_at'].isoformat()
    await db.appointments.insert_one(doc)
    
    # SMS gÃ¶nder
    settings_data = await db.settings.find_one({"organization_id": organization_id})
    if settings_data:
        company_name = settings_data.get("company_name", "Ä°ÅŸletmeniz")
        support_phone = settings_data.get("support_phone", "Destek HattÄ±")
        
        sms_message = (
            f"SayÄ±n {appointment.customer_name},\n\n"
            f"{company_name} hizmet randevunuz onaylanmÄ±ÅŸtÄ±r.\n\n"
            f"Tarih: {appointment.appointment_date}\n"
            f"Saat: {appointment.appointment_time}\n\n"
            f"Bilgi: {support_phone}\n\n"
            f"â€” {company_name}"
        )
        send_sms(appointment.phone, sms_message)
    
    # Emit WebSocket event for real-time update
    # Use appointment_obj.model_dump() instead of doc to avoid MongoDB _id issues
    appointment_for_emit = appointment_obj.model_dump()
    appointment_for_emit['created_at'] = appointment_for_emit['created_at'].isoformat()
    logger.info(f"About to emit appointment_created for org: {organization_id} (public endpoint)")
    try:
        await emit_to_organization(
            organization_id,
            'appointment_created',
            {'appointment': appointment_for_emit}
        )
        logger.info(f"Successfully emitted appointment_created for org: {organization_id} (public endpoint)")
    except Exception as emit_error:
        logger.error(f"Failed to emit appointment_created (public endpoint): {emit_error}", exc_info=True)
    
    return {"message": "Randevu baÅŸarÄ±yla oluÅŸturuldu", "appointment": appointment_obj}


# === ZORLU 405 HATASINI Ã‡Ã–ZMEK Ä°Ã‡Ä°N YENÄ° OPTIONS ENDPOINT'Ä° ===
@api_router.options("/{path:path}")
async def options_handler(response: Response, request: Request):
    response.status_code = status.HTTP_204_NO_CONTENT
    return response

# --- Router prefix'i buraya taÅŸÄ±ndÄ± ---
app.include_router(api_router, prefix="/api")

# Static files serving for logos (must be after router)
static_files_dir = str(ROOT_DIR / "static")
app.mount("/api/static", StaticFiles(directory=static_files_dir), name="static")

# --- CORS AyarÄ± ---
cors_origins_str = os.environ.get('CORS_ORIGINS', '*'); cors_origins = ['*'] if cors_origins_str == '*' else [origin.strip() for origin in cors_origins_str.split(',') if origin.strip()]
logging.info(f"CORS origins configured: {cors_origins}")
app.add_middleware(
    CORSMiddleware,
    allow_credentials=True,
    allow_origins=cors_origins,
    allow_methods=["GET", "POST", "PUT", "DELETE", "OPTIONS"], 
    allow_headers=["*"],
)

# Export socket_app as the main application for ASGI servers
# This allows both FastAPI and Socket.IO to work together
application = socket_app
